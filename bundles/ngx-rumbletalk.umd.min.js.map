{"version":3,"sources":["ng://ngx-rumbletalk/lib/ngx-rumbletalk.service.ts","ng://ngx-rumbletalk/lib/ngx-rumbletalk.component.ts","ng://ngx-rumbletalk/lib/ngx-rumbletalk.module.ts"],"names":["NgxRumbletalkService","prototype","address","hash","this","http","get","pipe","map","data","reload","url","Injectable","args","providedIn","HttpClient","server","messageInterval","floatingToggleInterval","protocol","baseWebUrl","NgxRumbletalkComponent","ngOnInit","_this","ua","navigator","userAgent","toUpperCase","mobile","indexOf","embedType","EMBED_TYPES","MOBILE_FULL","EMBEDDED","service","subscribe","iframeElement","nativeElement","src","addListeners","instantiateQuery","ngOnDestroy","clearInterval","window","addEventListener","info","bind","event","isFinite","res","status","HTMLIFrameElement","location","href","ignore","setInterval","query","origin_1","target","contentWindow","postMessage","validateOrigin","origin","test","handleImageLoad","parent","currentTarget","parentNode","style","height","width","chatDivElement","bottom","toggleFloatingChatStart","close","steps","visibility","overflow","toggleFloatingChat","chatDiv","offsetWidth","offsetHeight","check","openChat","iframeInterval","link","iframe","focus","tempIframe_1","open","closed","Component","selector","template","changeDetection","ChangeDetectionStrategy","OnPush","ViewChild","Input","FLOATING","counterTop","counterLeft","NgxRumbletalkModule","NgModule","declarations","imports","HttpClientModule","BrowserModule","exports"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class NgxRumbletalkService {\n  constructor(private http: HttpClient) {}\n\n  address(hash: string): Observable<string> {\n    return this.http\n      .get<string>(`https://www.rumbletalk.com/client/service.php?hash=${hash}`)\n      .pipe(map(data => data['address']));\n  }\n\n  reload(url: string): Observable<any> {\n    return this.http.get<any>(url);\n  }\n}\n","import {\n  Component,\n  OnInit,\n  OnDestroy,\n  Input,\n  ChangeDetectionStrategy,\n  ViewChild,\n  ElementRef\n} from '@angular/core';\nimport { NgxRumbletalkService } from './ngx-rumbletalk.service';\n\nconst protocol = 'https://';\nconst baseWebUrl = 'https://www.rumbletalk.com/';\nconst serviceRelativeUrl = 'client/service.php?hash=';\nlet server: string;\nlet messageInterval: any;\nlet floatingToggleInterval: any;\n\n@Component({\n  selector: 'ngx-rumbletalk',\n  templateUrl: './ngx-rumbletalk.component.html',\n  styleUrls: ['./ngx-rumbletalk.component.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class NgxRumbletalkComponent implements OnInit, OnDestroy {\n  /** @const Object different embedding types */\n  readonly EMBED_TYPES = {\n    EMBEDDED: 0,\n    FLOATING: 1,\n    MOBILE_FULL: 2\n  };\n  readonly counterTop = 14;\n  readonly counterLeft = 23;\n\n  @ViewChild('iframe') iframeElement: ElementRef;\n  @ViewChild('chatDiv') chatDivElement: ElementRef;\n  @Input() public hash: string;\n  @Input() public side: number;\n  @Input() public embedType: number;\n  @Input() public cdn: string;\n  @Input() public floating: boolean;\n  @Input() public width: number;\n  @Input() public height: number;\n  @Input() public bounce: number;\n  @Input() public image: string;\n  @Input() public showDetails: boolean;\n\n  mobile: boolean;\n\n  constructor(private service: NgxRumbletalkService) {}\n\n  ngOnInit() {\n    const ua = navigator.userAgent.toUpperCase();\n    this.mobile =\n      ua.indexOf('MOBILE') !== -1 || ua.indexOf('ANDROID') !== -1 || ua.indexOf('IOS') !== -1;\n\n    /* if web and embed type 2, treat as embedded (0) */\n    if (!this.mobile && this.embedType === this.EMBED_TYPES.MOBILE_FULL) {\n      this.embedType = this.EMBED_TYPES.EMBEDDED;\n    }\n\n    this.service.address(this.hash).subscribe(address => {\n      server = address;\n\n      if (!this.mobile) {\n        this.iframeElement.nativeElement.src = `https://${address}/${this.hash}/`;\n      }\n\n      this.addListeners();\n      this.instantiateQuery();\n    });\n  }\n\n  ngOnDestroy() {\n    clearInterval(messageInterval);\n  }\n\n  /**\n   * add the event listeners based on the embed type and device\n   */\n  addListeners(): void {\n    window.addEventListener('message', this.info.bind(this), false);\n  }\n\n  /**\n   * handles postMessage requests\n   * @param event - the event object\n   */\n  info(event) {\n    if (isFinite(event.data)) {\n      clearInterval(messageInterval);\n    } else if (typeof event.data === 'object') {\n      if (event.data.reload) {\n        this.reload();\n      }\n    }\n  }\n\n  /**\n   * reloads the iframe (or parent page) in case of a server request\n   */\n  reload() {\n    const url = `${baseWebUrl}${serviceRelativeUrl}${this.hash}`;\n\n    this.service.reload(url).subscribe(\n      res => {\n        if (res.status) {\n          server = res.address;\n          const address = `${protocol}${server}/${this.hash}/`;\n\n          if (this.iframeElement.nativeElement instanceof HTMLIFrameElement) {\n            this.iframeElement.nativeElement.src = address;\n          } else {\n            this.iframeElement.nativeElement.location.href = address;\n          }\n\n          this.instantiateQuery();\n        }\n      },\n      ignore => location.reload()\n    );\n  }\n\n  /**\n   * starts [repeatedly] trying to connect to the chat using postMessage\n   */\n  instantiateQuery() {\n    messageInterval = setInterval(this.query.bind(this), 1000);\n  }\n\n  /**\n   * instantiate a postMessage connection with the chat\n   */\n  query() {\n    try {\n      let target;\n      let origin;\n\n      if (this.iframeElement.nativeElement instanceof HTMLIFrameElement) {\n        target = this.iframeElement.nativeElement.contentWindow;\n        origin = protocol + server;\n      } else {\n        target = this.iframeElement.nativeElement;\n        origin = baseWebUrl;\n      }\n\n      target.postMessage('toolbar', origin);\n    } catch (ignore) {}\n  }\n\n  /**\n   * checks if the given origin is of a chat service\n   * @param origin - the URL of the origin\n   * returns boolean\n   */\n  validateOrigin(origin): boolean {\n    return /^https:\\/\\/.+\\.rumbletalk\\.(net|com)(:4433)?$/.test(origin);\n  }\n\n  handleImageLoad(event: any): void {\n    /* image element */\n    const target = event.target;\n    /* parent div */\n    const parent = event.currentTarget.parentNode;\n\n    /* match the dimensions of the image and the wrapping div */\n    parent.style.height = `${target.height}px`;\n    parent.style.width = `${target.width}px`;\n\n    /* place the chat div right above the image */\n    if (!this.mobile) {\n      this.chatDivElement.nativeElement.style.bottom = `${target.height}px`;\n    }\n  }\n\n  /**\n   * hides or shows the floating chat\n   * @param boolean [close] - if set to true, will force hide\n   */\n  toggleFloatingChatStart(close: boolean = false): void {\n    clearInterval(floatingToggleInterval);\n    let steps = -100;\n\n    if (this.chatDivElement.nativeElement.style.visibility === 'hidden' && !close) {\n      steps *= -1;\n      this.chatDivElement.nativeElement.style.width = 0;\n      this.chatDivElement.nativeElement.style.height = 0;\n      this.chatDivElement.nativeElement.style.overflow = 'visible';\n      this.chatDivElement.nativeElement.style.visibility = 'visible';\n    }\n\n    floatingToggleInterval = setInterval(() => {\n      this.toggleFloatingChat(steps);\n    }, 1);\n  }\n\n  /**\n   * hide or display the floating chat by @steps\n   * @param number steps - the number of pixels to increment the display by\n   */\n  toggleFloatingChat(steps): void {\n    const chatDiv = this.chatDivElement.nativeElement;\n    let width = chatDiv.offsetWidth + steps;\n    let height = chatDiv.offsetHeight + steps;\n    let check = 0;\n\n    if (width < 0) {\n      width = 0;\n    }\n\n    if (height < 0) {\n      height = 0;\n    }\n\n    if (width >= 0 && height >= 0) {\n      if (width <= this.width) {\n        check = 1;\n      } else {\n        width = this.width;\n      }\n\n      if (height <= this.height) {\n        check = 1;\n      } else {\n        height = this.height;\n      }\n\n      chatDiv.style.width = width + 'px';\n      chatDiv.style.height = height + 'px';\n    }\n\n    if (!check || width <= 0 || height <= 0) {\n      clearInterval(floatingToggleInterval);\n      if (width < this.width) {\n        chatDiv.style.visibility = 'hidden';\n        chatDiv.style.overflow = 'hidden';\n      }\n    }\n  }\n\n  /**\n   * attaches the open chat event to the given target\n   * @param Element target\n   */\n  openChat(): void {\n    const link = `${baseWebUrl}client/chat.php?${this.hash}`;\n    let iframeInterval;\n    const iframe = this.iframeElement;\n\n    if (iframe) {\n      iframe.nativeElement.focus();\n    } else {\n      const tempIframe = window.open(link);\n      iframeInterval = setInterval(() => {\n        if (tempIframe.closed) {\n          clearInterval(iframeInterval);\n        }\n      }, 100);\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { HttpClientModule } from '@angular/common/http';\nimport { NgxRumbletalkComponent } from './ngx-rumbletalk.component';\nimport { BrowserModule } from '@angular/platform-browser';\n\n@NgModule({\n  declarations: [NgxRumbletalkComponent],\n  imports: [HttpClientModule, BrowserModule],\n  exports: [NgxRumbletalkComponent]\n})\nexport class NgxRumbletalkModule {}\n"]}